# Квиз по модулю "Репозитории (Repositories)"

## Вопросы

1.  **Какова основная цель использования паттерна Репозиторий в Domain-Driven Design?**
    *   A) Для непосредственного выполнения SQL-запросов к базе данных.
    *   B) Для инкапсуляции логики доступа к данным и предоставления иллюзии коллекции объектов домена в памяти.
    *   C) Для управления транзакциями на уровне приложения.
    *   D) Для генерации пользовательского интерфейса на основе данных.

2.  **С какими элементами доменной модели Репозитории обычно работают напрямую?**
    *   A) Со всеми Сущностями и Объектами-Значениями.
    *   B) Только с Корнями Агрегатов (Aggregate Roots).
    *   C) Только с Объектами-Значениями.
    *   D) С Сервисами Приложения.

3.  **Что из перечисленного НЕ является типичной обязанностью Репозитория?**
    *   A) Сохранение Агрегата.
    *   B) Восстановление Агрегата по его идентификатору.
    *   C) Выполнение сложной бизнес-логики, изменяющей состояние Агрегата.
    *   D) Удаление Агрегата.

4.  **Какое утверждение о связи Репозиториев и деталей инфраструктуры (например, конкретной СУБД) является верным?**
    *   A) Интерфейс Репозитория должен быть тесно связан с используемой СУБД для максимальной производительности.
    *   B) Репозиторий должен полностью скрывать детали реализации хранения данных от доменного слоя.
    *   C) Доменный слой должен знать, какая СУБД используется, чтобы оптимизировать запросы через Репозиторий.
    *   D) Репозитории всегда должны использовать ORM.

5.  **Если вам нужно получить список Заказов (Orders), соответствующих определенным критериям (например, все оплаченные заказы за последний месяц), где должна быть определена эта логика запроса?**
    *   A) В Сервисе Приложения, который напрямую формирует SQL-запрос.
    *   B) Внутри Агрегата `Order`.
    *   C) В методе Репозитория Заказов (например, `findPaidOrdersFromLastMonth()`).
    *   D) В контроллере пользовательского интерфейса.

6.  **В чем ключевое отличие Репозитория от DAO (Data Access Object)?**
    *   A) DAO работает только с реляционными базами данных, а Репозиторий — с любыми.
    *   B) Репозиторий оперирует Агрегатами и имитирует коллекцию, тогда как DAO обычно более гранулярен и ориентирован на таблицы/записи.
    *   C) Репозитории всегда реализуются поверх DAO.
    *   D) Нет существенных отличий, это синонимы.

7.  **Должен ли метод `save()` (или `add()`) Репозитория всегда выполнять немедленную запись в базу данных?**
    *   A) Да, всегда для обеспечения консистентности.
    *   B) Нет, он может использовать паттерн Unit of Work для отложенной записи в рамках транзакции.
    *   C) Да, если не используется ORM.
    *   D) Нет, запись всегда должна происходить асинхронно.

8.  **Почему Репозитории обычно возвращают Корни Агрегатов, а не отдельные Сущности внутри Агрегата?**
    *   A) Это упрощает реализацию Репозитория.
    *   B) Для обеспечения того, что все инварианты Агрегата соблюдаются, так как доступ к внутренним частям идет только через Корень Агрегата.
    *   C) Это требование большинства ORM.
    *   D) Это позволяет избежать загрузки слишком большого количества данных.

9.  **При тестировании доменной логики, какой подход к Репозиториям является предпочтительным?**
    *   A) Всегда использовать реальную реализацию Репозитория, подключенную к тестовой базе данных.
    *   B) Использовать "in-memory" (в памяти) реализации интерфейса Репозитория для изоляции тестов.
    *   C) Мокировать (mock) каждый вызов методов Репозитория.
    *   D) Не тестировать код, который взаимодействует с Репозиториями.

10. **Что обычно происходит, если Репозиторий не может найти Агрегат по запрошенному идентификатору (например, в методе `findById`)?**
    *   A) Он должен создать и вернуть новый экземпляр Агрегата с этим ID.
    *   B) Он должен вернуть `None` (или `Optional.empty()` в Java/Kotlin) или выбросить специфическое исключение (например, `AggregateNotFoundException`).
    *   C) Он должен автоматически перенаправить запрос на другой Репозиторий.
    *   D) Он должен заблокировать выполнение до тех пор, пока Агрегат не появится.
