# Ответы на квиз по модулю "Репозитории (Repositories)"

## Ответы

1.  **Какова основная цель использования паттерна Репозиторий в Domain-Driven Design?**
    *   **Ответ: B) Для инкапсуляции логики доступа к данным и предоставления иллюзии коллекции объектов домена в памяти.**
    *   *Пояснение:* Репозиторий абстрагирует слой доступа к данным, позволяя доменному слою работать с объектами так, как будто они находятся в памяти, не заботясь о деталях их сохранения и извлечения.

2.  **С какими элементами доменной модели Репозитории обычно работают напрямую?**
    *   **Ответ: B) Только с Корнями Агрегатов (Aggregate Roots).**
    *   *Пояснение:* Это ключевой принцип DDD. Доступ к внутренним частям Агрегата должен осуществляться только через его Корень, чтобы гарантировать соблюдение инвариантов Агрегата. Репозиторий обеспечивает получение и сохранение целых Агрегатов.

3.  **Что из перечисленного НЕ является типичной обязанностью Репозитория?**
    *   **Ответ: C) Выполнение сложной бизнес-логики, изменяющей состояние Агрегата.**
    *   *Пояснение:* Бизнес-логика, изменяющая состояние Агрегата, должна находиться внутри самого Агрегата или, в некоторых случаях, в Доменных Сервисах. Репозиторий отвечает за персистентность, а не за изменение состояния.

4.  **Какое утверждение о связи Репозиториев и деталей инфраструктуры (например, конкретной СУБД) является верным?**
    *   **Ответ: B) Репозиторий должен полностью скрывать детали реализации хранения данных от доменного слоя.**
    *   *Пояснение:* Интерфейс Репозитория определяется в доменном слое, а его реализация — в инфраструктурном. Это позволяет менять способ хранения данных без изменения доменной логики.

5.  **Если вам нужно получить список Заказов (Orders), соответствующих определенным критериям (например, все оплаченные заказы за последний месяц), где должна быть определена эта логика запроса?**
    *   **Ответ: C) В методе Репозитория Заказов (например, `findPaidOrdersFromLastMonth()`).**
    *   *Пояснение:* Репозиторий может предоставлять методы для выполнения специфичных запросов, которые возвращают Агрегаты или их коллекции, соответствующие определенным критериям. Эти методы инкапсулируют логику формирования запроса к хранилищу.

6.  **В чем ключевое отличие Репозитория от DAO (Data Access Object)?**
    *   **Ответ: B) Репозиторий оперирует Агрегатами и имитирует коллекцию, тогда как DAO обычно более гранулярен и ориентирован на таблицы/записи.**
    *   *Пояснение:* Репозиторий — это более высокоуровневая абстракция, ориентированная на доменные объекты (Агрегаты). DAO часто является более низкоуровневым и ближе к структуре базы данных.

7.  **Должен ли метод `save()` (или `add()`) Репозитория всегда выполнять немедленную запись в базу данных?**
    *   **Ответ: B) Нет, он может использовать паттерн Unit of Work для отложенной записи в рамках транзакции.**
    *   *Пояснение:* Паттерн Unit of Work позволяет сгруппировать несколько операций с данными в одну транзакцию, оптимизируя взаимодействие с БД и обеспечивая атомарность.

8.  **Почему Репозитории обычно возвращают Корни Агрегатов, а не отдельные Сущности внутри Агрегата?**
    *   **Ответ: B) Для обеспечения того, что все инварианты Агрегата соблюдаются, так как доступ к внутренним частям идет только через Корень Агрегата.**
    *   *Пояснение:* Если бы Репозиторий возвращал внутренние сущности, это могло бы нарушить инкапсуляцию и целостность Агрегата.

9.  **При тестировании доменной логики, какой подход к Репозиториям является предпочтительным?**
    *   **Ответ: B) Использовать "in-memory" (в памяти) реализации интерфейса Репозитория для изоляции тестов.**
    *   *Пояснение:* "In-memory" реализации позволяют быстро и надежно тестировать доменную логику без необходимости поднимать реальную базу данных, что делает тесты независимыми от инфраструктуры.

10. **Что обычно происходит, если Репозиторий не может найти Агрегат по запрошенному идентификатору (например, в методе `findById`)?**
    *   **Ответ: B) Он должен вернуть `None` (или `Optional.empty()` в Java/Kotlin) или выбросить специфическое исключение (например, `AggregateNotFoundException`).**
    *   *Пояснение:* Это стандартные способы сигнализировать вызывающему коду об отсутствии запрошенного объекта. Создание нового объекта было бы некорректным поведением.
