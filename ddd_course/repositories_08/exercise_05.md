# Упражнение по модулю "Репозитории (Repositories)"

## Задание: Реализация Репозитория для Агрегата `Order`

В этом упражнении вам предстоит разработать интерфейс Репозитория для Агрегата `Order` (который мы использовали в предыдущих модулях) и создать его "in-memory" реализацию. Это позволит абстрагировать логику сохранения и извлечения заказов от остальной части приложения.

### Контекст:
Представьте, что ваше приложение для управления заказами должно уметь сохранять новые заказы, находить существующие заказы по их идентификатору или по идентификатору клиента, а также обновлять информацию о заказах. Репозиторий будет служить мостом между доменной моделью (Агрегатом `Order`) и механизмом хранения данных (в данном случае, простой коллекцией в памяти).

### Часть 1: Определение Интерфейса `OrderRepository`

1.  **Определите интерфейс `OrderRepository`** (например, с использованием `abc.ABC` и `@abc.abstractmethod`). Этот интерфейс должен находиться в доменном слое.
    Он должен включать следующие методы:
    *   `add(order: Order) -> None`:
        *   Добавляет новый экземпляр Агрегата `Order` в хранилище.
        *   Должен вызывать исключение (например, `OrderAlreadyExistsError`), если заказ с таким `order_id` уже существует.
    *   `get_by_id(order_id: OrderId) -> Optional[Order]`:
        *   Извлекает Агрегат `Order` из хранилища по его уникальному идентификатору `order_id`.
        *   Возвращает `Order`, если найден, иначе `None`.
    *   `save(order: Order) -> None`:
        *   Обновляет существующий экземпляр Агрегата `Order` в хранилище.
        *   Должен вызывать исключение (например, `OrderNotFoundError`), если заказ с таким `order_id` не найден для обновления.
        *   *Примечание:* Этот метод предназначен для обновления уже существующего в репозитории агрегата. Для добавления новых используйте `add`.
    *   `find_by_customer_id(customer_id: CustomerId) -> List[Order]`:
        *   Находит и возвращает список всех Агрегатов `Order`, принадлежащих указанному `customer_id`.
        *   Возвращает пустой список, если заказы для данного клиента не найдены.
    *   *(Опционально)* `delete(order_id: OrderId) -> None`:
        *   Удаляет Агрегат `Order` из хранилища по его `order_id`.
        *   Может вызывать исключение (например, `OrderNotFoundError`), если заказ не найден.

2.  **Используйте типы идентификаторов** (`OrderId`, `CustomerId`) и класс `Order`, определенные в предыдущих модулях.

### Часть 2: Реализация `InMemoryOrderRepository`

1.  **Создайте класс `InMemoryOrderRepository`**, который реализует интерфейс `OrderRepository`. Эта реализация будет находиться в инфраструктурном слое (или слое адаптеров).
2.  **Хранение данных**:
    *   Используйте внутренний словарь (например, `_orders: Dict[OrderId, Order]`) для хранения заказов в памяти. Ключом будет `order_id`.
3.  **Реализуйте все методы интерфейса**:
    *   `add`: Добавляет заказ в словарь. Проверяет на дубликаты.
    *   `get_by_id`: Ищет заказ в словаре по ключу. Возвращает копию объекта, чтобы избежать непреднамеренных изменений хранимого объекта вне репозитория (например, `copy.deepcopy(order)`).
    *   `save`: Находит заказ в словаре и заменяет его новой версией. Также рекомендуется сохранять и возвращать копии.
    *   `find_by_customer_id`: Итерируется по значениям словаря, фильтруя заказы по `customer_id`. Возвращает список копий найденных заказов.
    *   *(Опционально)* `delete`: Удаляет заказ из словаря.

4.  **Обработка ошибок**:
    *   Определите и используйте кастомные исключения, если это необходимо (например, `OrderNotFoundError`, `OrderAlreadyExistsError`).

### Часть 3: (Опционально) Тестирование

1.  Напишите несколько простых тестовых сценариев (можно прямо в `if __name__ == "__main__":` вашего файла с репозиторием) для проверки корректности работы вашей "in-memory" реализации:
    *   Добавление нового заказа.
    *   Попытка добавления заказа с существующим ID.
    *   Получение заказа по ID.
    *   Попытка получения несуществующего заказа.
    *   Обновление существующего заказа.
    *   Попытка обновления несуществующего заказа.
    *   Поиск заказов по ID клиента.

### Что нужно предоставить:
-   Код на Python с определением интерфейса `OrderRepository`.
-   Код на Python с реализацией класса `InMemoryOrderRepository`.
-   (Если определяли) Код кастомных исключений.
-   (Опционально) Примеры использования или простые тесты, демонстрирующие работу репозитория.
-   Не забудьте включить необходимые классы из предыдущих модулей (такие как `Order`, `OrderId`, `CustomerId`, `Money`, `ShippingAddress`, `OrderStatus`, `OrderItem`) или их упрощенные версии, достаточные для работы репозитория.

### Критерии оценки:
-   Корректность определения интерфейса `OrderRepository` в соответствии с принципами DDD.
-   Полная и корректная реализация всех методов интерфейса в `InMemoryOrderRepository`.
-   Правильное использование "in-memory" хранилища (например, словаря).
-   Обеспечение принципа "работа с копиями" при извлечении объектов из репозитория для предотвращения побочных эффектов.
-   Адекватная обработка краевых случаев и ошибок (например, отсутствие объекта, попытка добавить существующий).
-   Читаемость и чистота кода (соответствие PEP 8, наличие type hints и docstrings будет плюсом).

Удачи!
