# Модуль 10: Архитектура

## Содержание

- Обзор архитектурных подходов в DDD
- Слоистая архитектура (Layered Architecture)
- Шестиугольная архитектура (Hexagonal Architecture / Ports and Adapters)
- Чистая архитектура (Clean Architecture)
- CQRS (Command Query Responsibility Segregation)
- Event Sourcing
- Выбор подходящей архитектуры
- Примеры организации проекта

---

## 1. Обзор архитектурных подходов в DDD

Domain-Driven Design (DDD) не предписывает одну конкретную архитектуру, но он процветает в средах, где доменная модель изолирована и защищена от инфраструктурных и технических деталей. Существует несколько архитектурных стилей, которые хорошо сочетаются с принципами DDD, помогая достичь этой изоляции и сосредоточиться на бизнес-логике.

Основные цели выбора архитектуры в контексте DDD:
-   **Изоляция домена:** Защита доменного слоя от изменений в других частях системы (UI, база данных, внешние сервисы).
-   **Тестируемость:** Возможность легко тестировать доменную логику независимо от внешних зависимостей.
-   **Поддерживаемость и эволюция:** Гибкость для развития и изменения системы с течением времени.
-   **Ясность:** Четкое разделение ответственностей между слоями и компонентами.

Рассмотрим наиболее популярные архитектурные паттерны, совместимые с DDD.

## 2. Слоистая архитектура (Layered Architecture)

Это один из самых традиционных и широко известных архитектурных стилей. Система организуется в виде горизонтальных слоев, каждый из которых имеет свою специфическую ответственность.

Типичные слои:
1.  **Слой представления (Presentation Layer / UI Layer):** Отвечает за взаимодействие с пользователем или другими системами. Включает UI (веб-страницы, мобильные экраны) или API-эндпоинты.
2.  **Слой приложения (Application Layer):** Координирует варианты использования системы. Не содержит бизнес-логики, а делегирует ее доменному слою. Здесь находятся Сервисы Приложения.
3.  **Доменный слой (Domain Layer):** Сердце системы. Содержит всю бизнес-логику, Сущности, Объекты-значения, Агрегаты, Доменные события и Доменные сервисы. Этот слой не должен зависеть от других слоев.
4.  **Слой инфраструктуры (Infrastructure Layer):** Предоставляет технические возможности, такие как доступ к базам данных (Репозитории), отправка сообщений, взаимодействие с файловой системой и т.д. Реализует интерфейсы, определенные в доменном или прикладном слое.

**Правило зависимостей:** Слои могут зависеть только от слоев, находящихся ниже них (или, в некоторых интерпретациях, только от непосредственно нижнего слоя). Критически важно, чтобы доменный слой не зависел от слоя инфраструктуры или представления. Для этого используется Принцип Инверсии Зависимостей (DIP) – доменный слой определяет интерфейсы (например, для Репозиториев), а инфраструктурный слой их реализует.

**Преимущества:**
-   Простота понимания и реализации.
-   Четкое разделение ответственностей.

**Недостатки:**
-   Может привести к "просачиванию" зависимостей, если не строго следовать правилам.
-   Иногда сложно избежать зависимостей доменного слоя от инфраструктуры без явного применения DIP.

## 3. Шестиугольная архитектура (Hexagonal Architecture / Ports and Adapters)

Предложена Алистером Коберном, эта архитектура также нацелена на изоляцию доменной логики. Она представляет приложение как "шестиугольник" (центральную часть), содержащий доменную логику и сервисы приложения. Внешний мир взаимодействует с этим ядром через "порты".

-   **Ядро приложения (Application Core):** Включает доменный слой и слой приложения. Это "внутренность" шестиугольника.
-   **Порты (Ports):** Это интерфейсы, определяющие, как ядро приложения взаимодействует с внешним миром. Порты бывают двух типов:
    -   **Входящие порты (Driving/Input Ports):** API, который ядро предоставляет внешним акторам (например, UI, тесты, другие приложения). Часто реализуются Сервисами Приложения.
    -   **Исходящие порты (Driven/Output Ports):** Интерфейсы, которые ядро использует для получения данных или выполнения действий во внешнем мире (например, интерфейсы Репозиториев, интерфейсы для отправки уведомлений).
-   **Адаптеры (Adapters):** Это конкретные реализации, которые "подключаются" к портам и преобразуют взаимодействие между ядром и конкретными технологиями или инструментами.
    -   **Входящие адаптеры (Driving Adapters):** Например, веб-контроллеры, обработчики сообщений из очереди, консольные команды. Они принимают запросы извне, преобразуют их и вызывают соответствующие входящие порты.
    -   **Исходящие адаптеры (Driven Adapters):** Например, реализации Репозиториев для конкретной БД (SQLAlchemy-адаптер), клиенты для внешних API, email-сервисы. Они реализуют исходящие порты.

**Правило зависимостей:** Все зависимости направлены внутрь, к ядру приложения. Адаптеры зависят от портов, определенных в ядре, но ядро не знает о конкретных адаптерах.

**Преимущества:**
-   Отличная изоляция домена.
-   Высокая тестируемость (ядро можно тестировать с mock-адаптерами).
-   Гибкость в замене инфраструктурных компонентов.

**Недостатки:**
-   Может показаться сложнее на начальном этапе из-за большего количества интерфейсов и абстракций.

## 4. Чистая архитектура (Clean Architecture)

Предложена Робертом Мартином (Uncle Bob), эта архитектура очень похожа на Шестиугольную и Слоистую, но делает акцент на строгом соблюдении правила зависимостей и разделении на концентрические круги.

Основные слои (от центра к периферии):
1.  **Сущности (Entities):** Содержат бизнес-объекты и правила, применимые на уровне всей компании (наиболее общие). Это ядро домена.
2.  **Варианты использования (Use Cases / Interactors):** Содержат логику, специфичную для приложения. Оркеструют поток данных к Сущностям и от них. Аналогичны Сервисам Приложения.
3.  **Адаптеры интерфейсов (Interface Adapters):** Преобразуют данные из формата, удобного для Use Cases и Entities, в формат, удобный для внешних систем (UI, БД, веб). Включают презентеры, контроллеры, шлюзы (gateways, например, Репозитории).
4.  **Фреймворки и Драйверы (Frameworks and Drivers):** Самый внешний слой. Содержит конкретные технологии: UI фреймворки, базы данных, веб-серверы, внешние библиотеки.

**Правило зависимостей (The Dependency Rule):** Зависимости могут быть направлены только внутрь. Код во внутреннем круге не может ничего знать о коде во внешнем круге. В частности, имена переменных, функций или классов, объявленных во внешнем круге, не должны упоминаться во внутреннем коде. Данные, передаваемые между слоями, должны быть простыми структурами (DTO).

**Преимущества:**
-   Максимальная независимость от фреймворков, UI, БД.
-   Высочайшая тестируемость.
-   Четкое следование принципу инверсии зависимостей.

**Недостатки:**
-   Требует дисциплины и может привести к созданию большого количества мелких классов и интерфейсов.

## 5. CQRS (Command Query Responsibility Segregation)

CQRS — это паттерн, который разделяет операции изменения состояния системы (Команды) от операций чтения состояния (Запросы).

-   **Команды (Commands):** Объекты, представляющие намерение изменить состояние системы (например, `CreateOrderCommand`, `UpdateCustomerAddressCommand`). Они не возвращают данные, а только подтверждают успех или сообщают об ошибке. Обрабатываются "командной стороной" (write model).
-   **Запросы (Queries):** Объекты, представляющие намерение получить данные из системы (например, `GetOrderByIdQuery`, `FindCustomersByNameQuery`). Они не изменяют состояние, а только возвращают данные (часто в виде DTO, оптимизированных для отображения). Обрабатываются "запрос_ной стороной" (read model).

**Модели:**
-   **Write Model (Модель Записи):** Отвечает за обработку команд, валидацию бизнес-правил и сохранение изменений состояния. Часто использует Агрегаты DDD.
-   **Read Model (Модель Чтения):** Оптимизирована для быстрого выполнения запросов и отображения данных. Может быть денормализованной, использовать другие технологии хранения (например, NoSQL для сложных запросов, поисковые движки). Данные в Read Model обычно обновляются асинхронно на основе событий, генерируемых Write Model.

**Преимущества:**
-   **Масштабируемость:** Модели чтения и записи можно масштабировать независимо.
-   **Производительность:** Оптимизация моделей под конкретные задачи (запись или чтение).
-   **Гибкость:** Возможность использовать разные технологии для разных моделей.
-   **Упрощение доменной модели:** Write Model может быть более сфокусирована на инвариантах и бизнес-логике, не заботясь о сложных запросах.

**Недостатки:**
-   **Сложность:** Внедрение CQRS добавляет сложности, особенно с синхронизацией данных между моделями (eventual consistency).
-   ** eventual consistency (согласованность в конечном счете):** Данные в Read Model могут быть неактуальными на короткий промежуток времени.

CQRS часто используется совместно с Event Sourcing.

## 6. Event Sourcing (Событийная модель источника данных)

Event Sourcing — это подход, при котором все изменения состояния приложения сохраняются как последовательность событий. Вместо того чтобы хранить текущее состояние Агрегата, мы храним историю событий, которые привели к этому состоянию.

-   **Хранилище событий (Event Store):** База данных, оптимизированная для записи и чтения потоков событий.
-   **Восстановление состояния:** Текущее состояние Агрегата восстанавливается путем применения всех его событий из прошлого.
-   **Снимки (Snapshots):** Для оптимизации восстановления состояния Агрегатов с длинной историей событий могут использоваться снимки (периодическое сохранение полного состояния).

**Преимущества:**
-   **Полная история изменений:** Возможность анализа прошлых состояний, отладки, аудита.
-   **Временные запросы:** Возможность запросить состояние системы на любой момент времени в прошлом.
-   **Интеграция с CQRS:** События из Event Store являются отличным источником для построения и обновления Read Models.
-   **Устойчивость к ошибкам:** Если ошибка в логике привела к неправильному состоянию, можно исправить логику и переиграть события для восстановления корректного состояния (с осторожностью).

**Недостатки:**
-   **Сложность реализации:** Требует другого мышления и инструментов.
-   **Версионирование событий:** Изменение структуры событий со временем требует стратегий версионирования.
-   **Сложность запросов к текущему состоянию:** Если не используется CQRS, запросы к текущему состоянию могут быть неэффективными, так как требуют восстановления из событий.

## 7. Выбор подходящей архитектуры

Выбор архитектуры зависит от множества факторов:
-   **Сложность домена:** Для сложных доменов хорошо подходят архитектуры, обеспечивающие сильную изоляцию (Шестиугольная, Чистая).
-   **Требования к масштабируемости и производительности:** CQRS и Event Sourcing могут быть полезны для высоконагруженных систем.
-   **Размер и опыт команды:** Более сложные архитектуры требуют больше опыта.
-   **Требования к аудиту и истории:** Event Sourcing предоставляет эти возможности "из коробки".
-   **Необходимость интеграции с различными внешними системами:** Шестиугольная архитектура упрощает такие интеграции.

Часто начинают с более простой Слоистой архитектуры, применяя Принцип Инверсии Зависимостей, и по мере роста сложности и появления специфических требований могут внедряться элементы из других архитектур (например, CQRS для определенных частей системы).

Ключевым моментом является **изоляция доменного слоя**. Независимо от выбранной "большой" архитектуры, внутри доменного слоя должны соблюдаться принципы DDD: четкое определение Агрегатов, Сущностей, Объектов-значений, использование Репозиториев для абстракции персистентности и т.д.

## 8. Примеры организации проекта (структура директорий)

Структура проекта может варьироваться, но вот примерная организация, отражающая принципы Чистой/Шестиугольной архитектуры:

```
my_project/
├── src/
│   ├── my_project_name/
│   │   ├── application/                # Слой Приложения / Use Cases
│   │   │   ├── services/               # Сервисы Приложения
│   │   │   │   └── order_service.py
│   │   │   ├── dto/                    # Data Transfer Objects
│   │   │   │   └── order_dto.py
│   │   │   └── commands/               # Команды (если используется CQRS)
│   │   │       └── place_order_command.py
│   │   │   └── queries/                # Запросы (если используется CQRS)
│   │   │       └── get_order_query.py
│   │   │
│   │   ├── domain/                     # Доменный слой / Entities & Use Cases (внутренняя часть)
│   │   │   ├── model/                  # Модели домена (Агрегаты, Сущности, VO)
│   │   │   │   ├── __init__.py
│   │   │   │   ├── order.py
│   │   │   │   └── customer.py
│   │   │   ├── events/                 # Доменные события
│   │   │   │   └── order_placed_event.py
│   │   │   ├── services/               # Доменные сервисы
│   │   │   │   └── discount_service.py
│   │   │   └── repositories/           # Абстрактные интерфейсы репозиториев (порты)
│   │   │       └── abstract_order_repository.py
│   │   │
│   │   ├── infrastructure/             # Слой Инфраструктуры / Frameworks & Drivers / Adapters
│   │   │   ├── persistence/            # Реализации Репозиториев, ORM-модели
│   │   │   │   ├── __init__.py
│   │   │   │   ├── sqlalchemy/
│   │   │   │   │   ├── models.py       # SQLAlchemy ORM модели
│   │   │   │   │   └── order_repository.py # Реализация репозитория
│   │   │   │   └── in_memory_order_repository.py
│   │   │   ├── messaging/              # Адаптеры для очередей сообщений
│   │   │   ├── external_services/      # Клиенты для внешних API
│   │   │   └── unit_of_work.py         # Реализация Unit of Work
│   │   │
│   │   ├── presentation/               # Слой Представления / Interface Adapters (внешняя часть)
│   │   │   ├── api/                    # API контроллеры (FastAPI, Flask, Django)
│   │   │   │   └── v1/
│   │   │   │       └── order_routes.py
│   │   │   ├── cli/                    # Консольные команды
│   │   │   └── web/                    # Веб-интерфейс (если есть)
│   │   │
│   │   └── __init__.py
│   │   └── config.py                   # Конфигурация приложения
│
├── tests/
│   ├── unit/
│   │   ├── application/
│   │   └── domain/
│   ├── integration/
│   │   └── infrastructure/
│   └── e2e/
│       └── presentation/
│
├── pyproject.toml
├── README.md
└── ... (другие файлы: Dockerfile, .env, etc.)
```

Эта структура помогает поддерживать разделение ответственностей и следовать правилу зависимостей, направленному внутрь к домену.

Выбор и адаптация архитектуры — это итеративный процесс. Важно начать с принципов, которые способствуют созданию качественного ПО, и адаптировать структуру по мере развития проекта и углубления понимания домена.
