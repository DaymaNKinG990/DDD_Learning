# Модуль 11: Интеграция и Композиция в DDD

В реальных системах Ограниченные Контексты (Bounded Contexts) не существуют в полной изоляции. Им часто необходимо взаимодействовать и обмениваться данными. Этот модуль посвящен различным способам интеграции Ограниченных Контекстов и композиции более крупных систем из них.

## 1. Карты Контекстов (Context Maps)

Прежде чем интегрировать контексты, важно понимать их взаимосвязи. Карта Контекстов — это диаграмма, визуализирующая отношения между различными Ограниченными Контекстами в системе.

**Основные паттерны взаимоотношений на Карте Контекстов:**

*   **Партнерство (Partnership):**
    *   Два контекста/команды тесно сотрудничают и совместно определяют интерфейсы интеграции.
    *   Успех одного контекста напрямую зависит от успеха другого.
    *   Требует хорошей коммуникации и координации.

*   **Общее Ядро (Shared Kernel):**
    *   Небольшая, общая часть модели (код, данные), которую используют два или более контекста.
    *   Изменения в общем ядре должны согласовываться всеми командами.
    *   Риск: может стать "бутылочным горлышком" или слишком разрастись. Использовать с осторожностью.

*   **Клиент-Поставщик (Customer-Supplier):**
    *   Один контекст (`Поставщик`) предоставляет услуги или данные другому контексту (`Клиент`).
    *   Клиент зависит от Поставщика. Поставщик должен учитывать потребности Клиента.
    *   Часто используется для интеграции вышестоящих (upstream) и нижестоящих (downstream) систем.

*   **Конформист (Conformist):**
    *   Нижестоящий контекст (клиент) полностью принимает модель вышестоящего контекста (поставщика) "как есть".
    *   Используется, когда у команды клиента нет возможности влиять на модель поставщика (например, при интеграции с внешним API крупного вендора).
    *   Просто в реализации, но клиент сильно зависит от изменений у поставщика.

*   **Антикоррупционный Слой (Anti-Corruption Layer - ACL):**
    *   Нижестоящий контекст создает слой-посредник (ACL) для изоляции своей доменной модели от модели вышестоящего контекста.
    *   ACL транслирует данные и вызовы между двумя моделями.
    *   Защищает доменную модель клиента от "загрязнения" чужой моделью. Позволяет клиенту развиваться независимо.
    *   Требует дополнительных усилий на разработку и поддержку ACL.

*   **Отдельные Пути (Separate Ways):**
    *   Два контекста не имеют прямой интеграции.
    *   Используется, когда интеграция не приносит значимой ценности или слишком сложна.
    *   Каждый контекст развивается независимо.

*   **Опубликованный Язык (Published Language):**
    *   Четко определенный и документированный формат данных (например, XML, JSON Schema, Protocol Buffers) или API, который используется для интеграции между контекстами.
    *   Обеспечивает стабильность и понятность интеграции.

*   **Открытый Хост-Сервис (Open Host Service):**
    *   Контекст предоставляет набор сервисов (API) для доступа к своим возможностям.
    *   Определяет протокол для взаимодействия. Часто используется вместе с Опубликованным Языком.

**Пример Карты Контекстов:**

Представьте систему электронной коммерции:

*   **Контекст "Каталог Товаров"** (Поставщик для "Заказов" и "Рекомендаций")
    *   `[U]` (Upstream)
    *   Предоставляет информацию о товарах через Open Host Service (OHS) и Published Language (PL).
*   **Контекст "Управление Заказами"** (Клиент для "Каталога", Поставщик для "Доставки")
    *   `[D]` (Downstream) для Каталога, `[U]` для Доставки.
    *   Использует ACL для взаимодействия с "Каталогом" (чтобы не зависеть от его внутренней модели).
    *   Взаимодействует с "Доставкой" по принципу Клиент-Поставщик.
*   **Контекст "Рекомендации Товаров"** (Клиент для "Каталога" и "Заказов")
    *   `[D]` для обоих.
    *   Является Конформистом по отношению к данным из "Каталога" и "Заказов" (если модели простые и стабильные).
*   **Контекст "Управление Доставкой"** (Клиент для "Заказов")
    *   `[D]` для Заказов.
*   **Контекст "Платежи"** (Внешняя система, например, Stripe)
    *   Интеграция через ACL со стороны "Управления Заказами".

Диаграмма:
`[Каталог Товаров (OHS, PL)] <--(ACL)-- [Управление Заказами] --(Customer/Supplier)--> [Управление Доставкой]`
`         ^                                    ^`
`         | (Conformist)                       | (Conformist/ACL)`
`         +----[Рекомендации Товаров]-----------+`
`                                              | (ACL)`
`                                              +----[Платежи (Внешний)]`

## 2. Технические Способы Интеграции

После определения стратегических взаимосвязей на Карте Контекстов, необходимо выбрать технические способы их реализации.

*   **Синхронная интеграция:**
    *   **RPC (Remote Procedure Call) / REST API / gRPC:**
        *   Один контекст напрямую вызывает API другого контекста и ожидает ответа.
        *   Проще в реализации для простых сценариев.
        *   Проблемы: сильная связанность, каскадные сбои (если один сервис недоступен, другие тоже страдают), производительность (ожидание ответа).
        *   Подходит для команд (Commands), где нужен немедленный результат, или для запросов (Queries), где данные нужны "здесь и сейчас".
    *   **Общая База Данных (Database Integration - антипаттерн):**
        *   Несколько контекстов читают и пишут в одну и ту же базу данных.
        *   Крайне не рекомендуется в DDD, так как нарушает инкапсуляцию Ограниченных Контекстов и приводит к сильной связанности на уровне данных. Модели контекстов становятся переплетены.
        *   Допустимо только для Общего Ядра, если оно очень маленькое и стабильное.

*   **Асинхронная интеграция (через события):**
    *   **Обмен Сообщениями (Messaging) / Брокеры Сообщений (Message Brokers - RabbitMQ, Kafka, etc.):**
        *   Контексты обмениваются сообщениями (часто это Доменные События) через очередь или топик.
        *   Отправитель публикует сообщение и не ждет ответа. Получатели подписываются на интересующие их сообщения.
        *   **Преимущества:**
            *   **Слабая связанность (Decoupling):** Контексты не знают друг о друге напрямую, только о формате сообщений.
            *   **Отказоустойчивость (Resilience):** Если получатель временно недоступен, сообщение останется в очереди.
            *   **Масштабируемость:** Можно легко добавлять новых подписчиков.
            *   **Гибкость:** Позволяет реализовывать сложные потоки данных и саги.
        *   **Проблемы:**
            *   **Eventual Consistency:** Данные в разных контекстах становятся согласованными не мгновенно, а "в конечном итоге". Это нужно учитывать при проектировании.
            *   **Сложность отладки:** Отследить поток сообщений может быть сложнее, чем прямой вызов.
            *   **Управление схемой сообщений:** Необходимо версионирование и управление изменениями в формате сообщений (Опубликованный Язык).
    *   **Паттерны на основе событий:**
        *   **Публикация-Подписка (Publish-Subscribe):** Один контекст публикует событие, множество других могут на него подписаться.
        *   **Хореография Событий (Event Choreography):** Взаимодействие между контекстами координируется через последовательность событий, без центрального оркестратора.
        *   **Оркестрация Событий (Event Orchestration) / Саги (Sagas):** Центральный компонент (оркестратор или сага) управляет последовательностью шагов (локальных транзакций) в разных контекстах для выполнения распределенной бизнес-транзакции. Если какой-то шаг не удается, сага выполняет компенсирующие транзакции.

## 3. Проектирование API для Интеграции

Независимо от синхронного или асинхронного подхода, важно правильно спроектировать API (или формат сообщений) для взаимодействия.

*   **Ориентация на возможности (Capability-oriented API):**
    *   API должно отражать бизнес-возможности, предоставляемые контекстом, а не просто CRUD-операции над его внутренними данными.
    *   Пример: вместо `GET /orders/{id}/items` и `POST /orders/{id}/items` лучше `POST /orders/{id}/add-item` (команда) или `GET /orders/{id}/summary` (запрос).
*   **Использование Опубликованного Языка:**
    *   Четко определите схемы данных (DTOs, сообщения), используемые для интеграции.
    *   Используйте версионирование API/сообщений для обратной совместимости.
*   **Идемпотентность:**
    *   Для команд, особенно в асинхронных системах, важно, чтобы повторное выполнение команды (например, из-за сбоя сети) не приводило к дублированию данных или некорректному состоянию.
    *   API должно быть спроектировано так, чтобы безопасно обрабатывать повторные вызовы.
*   **Антикоррупционный Слой (ACL):**
    *   При интеграции с внешними или устаревшими системами, ACL на стороне клиента преобразует "чужую" модель в модель, удобную для собственного домена.
    *   ACL может включать:
        *   **Адаптер (Adapter):** Реализует интерфейс, необходимый клиенту, используя вызовы к внешнему сервису.
        *   **Транслятор (Translator):** Преобразует данные между двумя моделями.
        *   **Фасад (Facade):** Упрощает взаимодействие со сложным API внешнего сервиса.

## 4. Композиция UI (UI Composition)

Если разные Ограниченные Контексты имеют свои пользовательские интерфейсы, возникает задача их композиции в единое приложение для пользователя.

*   **Проблемы:**
    *   Как обеспечить единый внешний вид (look and feel)?
    *   Как передавать состояние и контекст между разными частями UI?
    *   Как избежать сильной связанности между UI-компонентами разных контекстов?

*   **Подходы:**
    *   **Монолитный фронтенд:**
        *   Единое фронтенд-приложение, которое взаимодействует с API разных бэкенд-контекстов.
        *   Проще в начале, но может стать громоздким и сложным в управлении.
    *   **Микрофронтенды (Micro Frontends):**
        *   Разбиение фронтенда на независимые части, каждая из которых разрабатывается и развертывается отдельной командой (часто соответствующей Ограниченному Контексту).
        *   **Способы композиции:**
            *   **Композиция на стороне сервера (Server-Side Composition):** Сервер собирает страницы из фрагментов, предоставляемых разными микрофронтендами.
            *   **Композиция во время сборки (Build-Time Composition):** Микрофронтенды публикуются как пакеты, которые собираются в единое приложение.
            *   **Композиция на стороне клиента (Client-Side Composition):** Основное приложение-контейнер загружает и отображает микрофронтенды во время выполнения (например, через iframes, веб-компоненты или JavaScript-фреймворки).
        *   **Преимущества:** Независимая разработка и развертывание, технологическая гибкость для каждой команды.
        *   **Сложности:** Координация, управление общими зависимостями, производительность, обеспечение консистентного UX.
    *   **Гиперссылки (Hyperlinks):**
        *   Простейший способ: UI одного контекста просто ссылается на UI другого контекста.
        *   Подходит для слабо связанных систем.

## Заключение

Интеграция и композиция Ограниченных Контекстов — ключевой аспект построения сложных систем с использованием DDD. Выбор правильных стратегических паттернов (Карта Контекстов) и технических решений (синхронные/асинхронные вызовы, API, композиция UI) зависит от конкретных требований, масштаба системы и организационной структуры команд. Главная цель — обеспечить необходимый уровень взаимодействия, сохраняя при этом автономность и целостность каждого Ограниченного Контекста.
