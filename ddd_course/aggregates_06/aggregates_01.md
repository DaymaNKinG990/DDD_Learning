# Модуль 6: Агрегаты (Aggregates)

## Содержание

- Что такое Агрегаты
- Корень Агрегата (Aggregate Root)
- Границы согласованности (Consistency Boundaries)
- Инварианты и их защита
- Правила проектирования Агрегатов
- Связь с Сущностями и Объектами-значениями
- Реализация на Python
- Примеры

---

## 1. Что такое Агрегаты (Aggregates)?

В Domain-Driven Design (DDD) **Агрегат (Aggregate)** — это кластер из одной или нескольких связанных Сущностей (Entities) и Объектов-значений (Value Objects), который рассматривается как единое целое с точки зрения изменения данных. Агрегаты помогают управлять сложностью модели, группируя объекты, которые должны быть согласованы друг с другом.

Ключевые характеристики Агрегатов:
-   **Граница согласованности:** Агрегат определяет четкую границу, внутри которой должны соблюдаться инварианты (бизнес-правила) при любых изменениях.
-   **Корень Агрегата (Aggregate Root):** Каждым Агрегатом управляет одна Сущность, называемая Корнем Агрегата. Это единственная точка входа для всех операций, изменяющих состояние Агрегата.
-   **Транзакционная целостность:** Изменения внутри Агрегата обычно сохраняются как одна атомарная операция (транзакция).
-   **Ссылки:** Внешние объекты могут ссылаться только на Корень Агрегата. Внутренние объекты Агрегата не должны быть доступны напрямую извне.

Агрегаты упрощают модель, уменьшая количество связей между объектами и обеспечивая согласованность данных.

## 2. Корень Агрегата (Aggregate Root)

**Корень Агрегата (Aggregate Root)** — это конкретная Сущность внутри Агрегата, которая служит "фасадом" для всего кластера объектов.

Основные обязанности и характеристики Корня Агрегата:
-   **Единственная точка входа:** Все команды на изменение состояния Агрегата должны проходить через методы Корня Агрегата.
-   **Глобальная идентичность:** Корень Агрегата имеет глобальную идентичность (ID), по которой на него можно ссылаться из других Агрегатов или частей системы.
-   **Защита инвариантов:** Корень Агрегата отвечает за проверку и поддержание всех инвариантов (бизнес-правил), которые охватывают объекты внутри Агрегата.
-   **Управление жизненным циклом:** Корень Агрегата может управлять созданием и удалением внутренних Сущностей и Объектов-значений Агрегата.
-   **Загрузка и сохранение:** Репозитории обычно работают с Агрегатами целиком, загружая и сохраняя их через Корень Агрегата.

Примеры Корней Агрегатов: `Заказ` (может содержать `ПозицииЗаказа` и `АдресДоставки`), `Пользователь` (может содержать `ПрофильПользователя` и `НастройкиУведомлений`).

## 3. Границы согласованности (Consistency Boundaries)

Агрегат определяет **границу согласованности**. Это означает, что все объекты внутри Агрегата должны быть консистентны друг с другом в любой момент времени, особенно после завершения транзакции.

-   **Инварианты:** Бизнес-правила, которые должны всегда соблюдаться для объектов внутри Агрегата. Например, "общая сумма заказа должна быть равна сумме стоимостей всех позиций заказа".
-   **Атомарность изменений:** Когда Корень Агрегата обрабатывает команду, все необходимые изменения внутри Агрегата (включая его внутренние Сущности и Объекты-значения) должны быть выполнены атомарно. Либо все изменения успешно применяются, либо ни одно из них.

Границы Агрегата помогают локализовать логику согласованности и упрощают рассуждения о состоянии системы. Вместо того чтобы беспокоиться о согласованности всей системы сразу, мы фокусируемся на поддержании согласованности внутри каждого Агрегата.

Согласованность *между* Агрегатами обычно является **итоговой (eventual consistency)** и достигается с помощью доменных событий или других механизмов.

## 4. Инварианты и их защита

**Инварианты** — это правила, которые должны оставаться истинными для Агрегата на протяжении всего его жизненного цикла, за исключением моментов выполнения операций, которые могут временно их нарушать, но к концу операции должны восстановить.

-   Корень Агрегата отвечает за защиту этих инвариантов.
-   Любая операция, которая может изменить состояние Агрегата, должна быть реализована как метод Корня Агрегата.
-   Перед изменением состояния Корень Агрегата должен проверить, что предполагаемое изменение не нарушит инварианты. Если нарушит, операция должна быть отклонена (например, выброшено исключение).

Пример инварианта для Агрегата `Заказ`:
-   "Количество товара в позиции заказа не может быть отрицательным."
-   "Общая стоимость заказа должна корректно рассчитываться на основе позиций и скидок."
-   "Заказ не может быть оплачен, если он уже отменен."

## 5. Правила проектирования Агрегатов

При проектировании Агрегатов полезно следовать нескольким эмпирическим правилам:

1.  **Защищайте инварианты:** Главная цель Агрегата — обеспечить согласованность данных внутри его границ.
2.  **Проектируйте маленькие Агрегаты:** Чем меньше Агрегат, тем ниже вероятность конфликтов при одновременном доступе и тем выше производительность (меньше данных для загрузки/сохранения).
    -   Задавайте себе вопрос: "Действительно ли эти объекты должны изменяться вместе в одной транзакции?"
3.  **Ссылайтесь на другие Агрегаты по ID:** Вместо прямых объектных ссылок на другие Агрегаты, используйте их идентификаторы. Это помогает сохранять границы Агрегатов четкими и избегать каскадных загрузок.
    -   Если вам нужны данные из другого Агрегата, запросите их у соответствующего Репозитория по ID или используйте Доменные События для получения необходимой информации.
4.  **Обновляйте Агрегаты в рамках одной транзакции:** Изменения в одном Агрегате должны быть атомарны.
5.  **Используйте итоговую согласованность между Агрегатами:** Если бизнес-правило охватывает несколько Агрегатов, обеспечьте его соблюдение через механизмы итоговой согласованности (например, доменные события и обработчики событий).

## 6. Связь с Сущностями и Объектами-значениями

-   **Корень Агрегата** всегда является Сущностью.
-   Агрегат может содержать другие **Сущности** (локальные для Агрегата, их идентичность важна только внутри него) и **Объекты-значения**.
-   Внутренние Сущности Агрегата не имеют глобальной идентичности за пределами Агрегата. На них нельзя ссылаться напрямую извне.

## 7. Реализация на Python

```python
import uuid
from decimal import Decimal
from typing import List, Optional
from dataclasses import dataclass # Добавим для Money

# Предположим, у нас есть Value Object Money и Entity Product (упрощенно)
@dataclass(frozen=True)
class Money:
    amount: Decimal
    currency: str
    # ... (реализация как в модуле Value Objects) ...

class Product: # Упрощенная сущность для примера
    def __init__(self, product_id: uuid.UUID, name: str, price: Money):
        self.id: uuid.UUID = product_id
        self.name: str = name
        self.price: Money = price
    # ...

# Сущность внутри Агрегата Заказ
class OrderItem:
    def __init__(self, item_id: uuid.UUID, product: Product, quantity: int):
        if quantity <= 0:
            raise ValueError("Quantity must be positive.")
        self.id: uuid.UUID = item_id # Локальная идентичность внутри Заказа
        self.product: Product = product # Ссылка на Product (может быть просто product_id)
        self.quantity: int = quantity
        self.price_at_purchase: Money = product.price # Фиксируем цену на момент добавления

    @property
    def cost(self) -> Money:
        # Предполагаем, что Money поддерживает умножение на число
        return Money(self.price_at_purchase.amount * self.quantity, self.price_at_purchase.currency)

# Корень Агрегата - Заказ (Order)
class Order:
    def __init__(self, order_id: uuid.UUID, customer_id: uuid.UUID):
        self._id: uuid.UUID = order_id
        self._customer_id: uuid.UUID = customer_id # Ссылка на другой Агрегат (Клиент) по ID
        self._items: List[OrderItem] = []
        self._status: str = "PENDING" # Например: PENDING, PAID, SHIPPED, CANCELLED
        # ... другие атрибуты, например, адрес доставки (может быть Value Object)

    @property
    def id(self) -> uuid.UUID:
        return self._id

    @property
    def customer_id(self) -> uuid.UUID:
        return self._customer_id

    @property
    def items(self) -> List[OrderItem]:
        return list(self._items) # Возвращаем копию, чтобы предотвратить внешнее изменение списка

    @property
    def status(self) -> str:
        return self._status

    @property
    def total_amount(self) -> Money:
        if not self._items:
            # Нужна валюта по умолчанию или логика ее определения
            # Для простоты, если нет товаров, сумма 0 в некой базовой валюте (например, USD)
            # В реальном приложении это нужно продумать лучше.
            # Возможно, Заказ должен иметь валюту.
            return Money(Decimal("0"), "USD")

        # Предполагаем, что все товары в одной валюте или есть конвертация
        # Здесь для простоты берем валюту первого товара
        currency = self._items[0].cost.currency
        total = sum((item.cost.amount for item in self._items), Decimal("0"))
        return Money(total, currency)

    def add_item(self, product: Product, quantity: int):
        if self._status != "PENDING":
            raise ValueError("Cannot add items to an order that is not pending.")
        if quantity <= 0:
            raise ValueError("Quantity must be positive.")

        # Проверка инварианта: не более X позиций в заказе (пример)
        if len(self._items) >= 10:
            raise ValueError("Order cannot have more than 10 items.")

        # Проверка, есть ли уже такой продукт в заказе
        for item in self._items:
            if item.product.id == product.id:
                # Если продукт уже есть, можно обновить количество или выбросить ошибку
                # Здесь для примера обновим количество (но это усложняет OrderItem)
                # Лучше, если OrderItem неизменяем, тогда удаляем старый и добавляем новый
                # или просто запрещаем дублирование и требуем вызова update_item_quantity
                raise ValueError(f"Product {product.name} already in order. Use update_item_quantity.")

        order_item_id = uuid.uuid4() # Генерируем ID для OrderItem
        new_item = OrderItem(order_item_id, product, quantity)
        self._items.append(new_item)
        print(f"Product {product.name} added to order {self.id}.")
        # Здесь могут генерироваться Доменные События, например, OrderItemAdded

    def remove_item(self, product_id: uuid.UUID):
        if self._status != "PENDING":
            raise ValueError("Cannot remove items from an order that is not pending.")

        item_to_remove = None
        for item in self._items:
            if item.product.id == product_id:
                item_to_remove = item
                break

        if item_to_remove:
            self._items.remove(item_to_remove)
            print(f"Product with ID {product_id} removed from order {self.id}.")
        else:
            raise ValueError(f"Product with ID {product_id} not found in order.")

    def pay(self):
        if self._status != "PENDING":
            raise ValueError(f"Order cannot be paid. Current status: {self._status}")
        if not self._items:
            raise ValueError("Cannot pay for an empty order.")

        # Здесь могла бы быть логика взаимодействия с платежной системой
        self._status = "PAID"
        print(f"Order {self.id} has been paid. Total: {self.total_amount}")
        # Здесь может генерироваться Доменное Событие OrderPaid

    def cancel(self):
        if self._status == "SHIPPED" or self._status == "CANCELLED":
            raise ValueError(f"Order cannot be cancelled. Current status: {self._status}")
        self._status = "CANCELLED"
        print(f"Order {self.id} has been cancelled.")
        # Здесь может генерироваться Доменное Событие OrderCancelled

    def __eq__(self, other):
        if not isinstance(other, Order):
            return NotImplemented
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

```

**Ключевые моменты реализации:**
-   `Order` является Корнем Агрегата.
-   `OrderItem` является Сущностью внутри Агрегата `Order`. Её ID (`item_id`) имеет значение только в контексте конкретного Заказа.
-   Методы `add_item`, `remove_item`, `pay`, `cancel` являются операциями, изменяющими состояние Агрегата, и реализованы на Корне Агрегата. Они защищают инварианты (например, нельзя добавить товар в оплаченный заказ).
-   Ссылка на `Customer` (другой Агрегат) хранится как `_customer_id`.
-   `total_amount` рассчитывается на основе внутренних `OrderItem`.

## 8. Примеры

### Агрегат `BlogPost`

-   **Корень Агрегата:** `BlogPost` (Сущность)
    -   ID (глобальный)
    -   Заголовок
    -   Содержимое
    -   Статус (черновик, опубликован, архивирован)
    -   Дата публикации
    -   Автор ID (ссылка на Агрегат `User`)
-   **Внутренние объекты:**
    -   `Comment` (Сущность, локальная идентичность)
        -   ID комментария (локальный)
        -   Текст комментария
        -   Автор комментария (может быть Value Object с именем и email, или ID пользователя)
        -   Дата создания
    -   `Tag` (может быть Value Object, если теги простые строки, или Сущность, если теги имеют собственное управление)
-   **Инварианты:**
    -   Нельзя добавить комментарий к неопубликованному посту.
    -   Заголовок и содержимое не могут быть пустыми для публикации.
    -   Дата публикации не может быть в прошлом при первой публикации.
-   **Операции на Корне:**
    -   `publish()`
    -   `add_comment(text, author_info)`
    -   `update_content(new_content)`
    -   `archive()`

Агрегаты — мощный инструмент для структурирования сложной доменной логики и обеспечения согласованности данных. Правильное определение границ Агрегатов является ключевым аспектом успешного применения DDD.
